{"./":{"url":"./","title":"关于本书","keywords":"","body":"JDK8源码阅读 jdk版本为1.8.0_131 示例代码 gitbook源码 "},"content/java/":{"url":"content/java/","title":"java","keywords":"","body":"java包 Java SE的标准库，是java标准的一部分，是对外承诺的java开发接口，通常要保持向后兼容，一般不会轻易修改。包括其他厂家(IBMJDK/HPJDK/OpenJDK)在内，所有jdk的实现，在java.*上都是一样的。 "},"content/java/lang/":{"url":"content/java/lang/","title":"lang","keywords":"","body":"java.lang包 该包提供了Java编程的基础类，例如 Object、Math、String、StringBuffer、System、Thread等 "},"content/java/lang/Thread.html":{"url":"content/java/lang/Thread.html","title":"Thread","keywords":"","body":"线程状态转换 "},"content/java/util/":{"url":"content/java/util/","title":"util","keywords":"","body":"java.util包 该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 "},"content/java/util/concurrent/":{"url":"content/java/util/concurrent/","title":"concurrent","keywords":"","body":"java.util.concurrent包 Java5添加了一个新的包到Java平台，java.util.concurrent包。这个包包含有一系列能够让Java的并发编程变得更加简单轻松的类。 "},"content/java/util/concurrent/atomic/":{"url":"content/java/util/concurrent/atomic/","title":"atomic","keywords":"","body":"java.util.concurrent.atomic包 atomic包是专门为线程安全设计的Java包，包含多个原子操作类。 在atomic中频繁的用到了Unsafe，如果不明白可以先看看Unsafe的API。 Atomic类型主要分为以下几类: 基本类:AtomicInteger、AtomicLong、AtomicBoolean 引用类型:AtomicReference、AtomicStampedReference、AtomicMarkableReference 数组类型:AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray 属性原子修改器:AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater 累加器:DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder 自旋锁 与互斥锁相似，基本作用是用于线程（进程）之间的同步，该锁作用于共享资源。 与互斥锁不同的是该锁不会让没获得锁的线程阻塞，没获得锁的线程不会放弃CPU时间片， 而是在原地忙等，直到锁的持有者释放锁，可见，自旋锁是非阻塞锁。可能引起的问题: 过多的占据CPU时间 死锁java中可以通过Unsafe中的CAS实现自旋锁，compareAndSwapInt、compareAndSwapLong、compareAndSwapObject。 CAS CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 CAS是非阻塞的，一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。 ABA问题 CAS看起来很爽，但是会导致“ABA问题”。ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。 关于ABA问题的一个例子：在你非常渴的情况下你发现一个盛满水的杯子，你一饮而尽， 之后再给杯子里重新倒满水。然后你离开，当杯子的真正主人回来时看到杯子还是盛满水， 他当然不知道是否被人喝完重新倒满。解决这个问题的方案的一个策略是每一次倒水假设有一个自动记录仪记录下， 这样主人回来就可以分辨在她离开后是否发生过重新倒满的情况。这也是解决ABA问题目前采用的策略。 ------ 自知乎 "},"content/java/util/concurrent/atomic/AtomicBoolean.html":{"url":"content/java/util/concurrent/atomic/AtomicBoolean.html","title":"AtomicBoolean","keywords":"","body":"AtomicBoolean 可以用原子方式更新的boolean值。AtomicBoolean可用在应用程序中（如以原子方式更新的标志），但不能用于替换Boolean。 静态块 static { try { // 获得volatile变量value的内存地址偏移量 // 修改value值时根据该偏移量进行 valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } 构造方法 AtomicBoolean() 初始值为boolean基本类型默认值false AtomicBoolean(boolean initialValue) 初始值为initialValue 方法 boolean get() // 返回当前值 public final boolean get() { return value != 0; } void set() // 无条件设置value为新值 public final void set(boolean newValue) { value = newValue ? 1 : 0; } boolean compareAndSet(boolean expect, boolean update) // 将当前value值跟expect预期值比较 若相同将value更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); } boolean weakCompareAndSet(boolean expect, boolean update) // 作用同compareAndSet // 但是作者注释\"可能意外失败并且不提供排序保证\" 但是改功能没有实现 // 区别compareAndSet方法有final修饰 不能重写 // weakCompareAndSet可以重新 可以通过继承AtomicBoolean重写此方法 public boolean weakCompareAndSet(boolean expect, boolean update) { int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); } void lazySet(boolean newValue) // 该方法不能保证newValue修改立刻被其他线程看到 // putOrderedInt是putIntVolatile的延迟实现 public final void lazySet(boolean newValue) { int v = newValue ? 1 : 0; unsafe.putOrderedInt(this, valueOffset, v); } boolean getAndSet(boolean newValue) // 原子方式更新value 并返回旧值 // 自旋锁方式实现 public final boolean getAndSet(boolean newValue) { boolean prev; do { prev = get(); } while (!compareAndSet(prev, newValue)); // 保证拿到的是最新值 return prev; } "},"content/java/util/concurrent/atomic/AtomicInteger.html":{"url":"content/java/util/concurrent/atomic/AtomicInteger.html","title":"AtomicInteger","keywords":"","body":"AtomicInteger 可以用原子方式更新的int值。AtomicInteger可用在应用程序中（如以原子方式更新的标志），但不能用于替换Integer。 此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。 在java并发编程中，会出现i++，i--等操作，但是这些不是原子性操作，这在线程安全上面就会出现相应的问题。因此java提供了相应类的原子性操作类。 静态块 static { try { // 获得volatile变量value的内存地址偏移量 // 修改value值时根据该偏移量进行 valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } 构造方法 AtomicInteger() 初始值为int基本类型默认值0 AtomicInteger(int initialValue) 初始值为initialValue 方法 int get() // 返回当前值 public final int get() { return value; } void set() // 无条件设置value为新值 public final void set(int newValue) { value = newValue; } boolean compareAndSet(int expect, int update) // 将当前value值跟expect预期值比较 若相同将value更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } boolean weakCompareAndSet(boolean expect, boolean update) // 作用同compareAndSet // 但是作者注释\"可能意外失败并且不提供排序保证\" 但是改功能没有实现 // 区别compareAndSet方法有final修饰 不能重写 // weakCompareAndSet可以重新 可以通过继承AtomicInteger重写此方法 public boolean weakCompareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } void lazySet(int newValue) // 该方法不能保证newValue修改立刻被其他线程看到 // putOrderedInt是putIntVolatile的延迟实现 public final void lazySet(int newValue) { unsafe.putOrderedInt(this, valueOffset, newValue); } int getAndSet(int newValue) // 原子方式更新value 并返回旧值 public final int getAndSet(int newValue) { return unsafe.getAndSetInt(this, valueOffset, newValue); } int getAndIncrement() // 原子的i++操作 返回i public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } int incrementAndGet() // 原子的++i操作 返回i+1 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1; } int getAndDecrement() // 原子的i--操作 返回i public final int getAndDecrement() { return unsafe.getAndAddInt(this, valueOffset, -1); } int decrementAndGet() // 原子--i操作 返回i-1 public final int decrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, -1) - 1; } int getAndAdd(int delta) // 原子的(i+delta)操作 返回i public final int getAndAdd(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta); } int addAndGet(int delta) // 原子的(i+delta)操作 返回i+delta public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } int getAndUpdate(IntUnaryOperator updateFunction) // 对旧值进行一元操作 返回旧值 public final int getAndUpdate(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return prev; } int updateAndGet(IntUnaryOperator updateFunction) // 对旧值进行一元操作 返回新值 public final int updateAndGet(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return next; } int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) // 对旧值进行二元操作 返回旧值 public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return prev; } int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) // 对旧值进行二元操作 返回新值 public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicLong.html":{"url":"content/java/util/concurrent/atomic/AtomicLong.html","title":"AtomicLong","keywords":"","body":"AtomicLong 可以用原子方式更新的long值。AtomicLong可用在应用程序中（如以原子方式更新的标志），但不能用于替换Long。 此类确实扩展了 Number，允许那些处理基于数字类的工具和实用工具进行统一访问。 静态块 static { try { // 获得volatile变量value的内存地址偏移量 // 修改value值时根据该偏移量进行 valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } 构造方法 AtomicLong() 初始值为long基本类型默认值0 AtomicLong(long initialValue) 初始值为initialValue 方法 long get() // 返回当前值 public final long get() { return value; } void set() // 无条件设置value为新值 public final void set(long newValue) { value = newValue; } boolean compareAndSet(long expect, long update) // 将当前value值跟expect预期值比较 若相同将value更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(long expect, long update) { return unsafe.compareAndSwapLong(this, valueOffset, expect, update); } boolean weakCompareAndSet(long expect, long update) // 作用同compareAndSet // 但是作者注释\"可能意外失败并且不提供排序保证\" 但是改功能没有实现 // 区别compareAndSet方法有final修饰 不能重写 // weakCompareAndSet可以重新 可以通过继承AtomicLong重写此方法 public boolean weakCompareAndSet(long expect, long update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } void lazySet(long newValue) // 该方法不能保证newValue修改立刻被其他线程看到 // putOrderedLong是putLongVolatile的延迟实现 public final void lazySet(long newValue) { unsafe.putOrderedLong(this, valueOffset, newValue); } long getAndSet(long newValue) // 原子方式更新value 并返回旧值 public final long getAndSet(long newValue) { return unsafe.getAndSetLong(this, valueOffset, newValue); } long getAndIncrement() // 原子的i++操作 返回i public final long getAndIncrement() { return unsafe.getAndAddLong(this, valueOffset, 1); } long incrementAndGet() // 原子的++i操作 返回i+1 public final long incrementAndGet() { return unsafe.getAndAddLong(this, valueOffset, 1) + 1; } long getAndDecrement() // 原子的i--操作 返回i public final long getAndDecrement() { return unsafe.getAndAddLong(this, valueOffset, -1); } long decrementAndGet() // 原子--i操作 返回i-1 public final long decrementAndGet() { return unsafe.getAndAddLong(this, valueOffset, -1) - 1; } long getAndAdd(long delta) // 原子的(i+delta)操作 返回旧值 public final long getAndAdd(long delta) { return unsafe.getAndAddLong(this, valueOffset, delta); } long addAndGet(long delta) // 原子的(i+delta)操作 返回i+delta public final long addAndGet(long delta) { return unsafe.getAndAddLong(this, valueOffset, delta) + delta; } int getAndUpdate(LongUnaryOperator updateFunction) // 对旧值进行一元操作 返回旧值 public final long getAndUpdate(LongUnaryOperator updateFunction) { long prev, next; do { prev = get(); next = updateFunction.applyAsLong(prev); } while (!compareAndSet(prev, next)); return prev; } long updateAndGet(LongUnaryOperator updateFunction) // 对旧值进行一元操作 返回新值 public final long updateAndGet(LongUnaryOperator updateFunction) { long prev, next; do { prev = get(); next = updateFunction.applyAsLong(prev); } while (!compareAndSet(prev, next)); return next; } long getAndAccumulate(long x, LongBinaryOperator accumulatorFunction) // 对旧值进行二元操作 返回旧值 public final long getAndAccumulate(long x, LongBinaryOperator accumulatorFunction) { long prev, next; do { prev = get(); next = accumulatorFunction.applyAsLong(prev, x); } while (!compareAndSet(prev, next)); return prev; } long accumulateAndGet(long x, LongBinaryOperator accumulatorFunction) // 对旧值进行二元操作 返回新值 public final long accumulateAndGet(long x, LongBinaryOperator accumulatorFunction) { long prev, next; do { prev = get(); next = accumulatorFunction.applyAsLong(prev, x); } while (!compareAndSet(prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicReference.html":{"url":"content/java/util/concurrent/atomic/AtomicReference.html","title":"AtomicReference","keywords":"","body":"AtomicReference 可以用原子方式更新的对象引用。 静态块 static { try { // 获得volatile变量value的内存地址偏移量 // 修改value值时根据该偏移量进行 valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } 构造方法 AtomicReference() 初始值为null AtomicLong(V initialValue) 初始值为initialValue 方法 V get() // 返回当前值 public final V get() { return value; } void set() // 无条件设置value为新值 // 此方法非原子的 public final void set(V newValue) { value = newValue; } boolean compareAndSet(V expect, V update) // 将当前value值跟expect预期值比较 若相同将value更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } boolean weakCompareAndSet(V expect, V update) // 作用同compareAndSet // 但是作者注释\"可能意外失败并且不提供排序保证\" 但是改功能没有实现 // 区别compareAndSet方法有final修饰 不能重写 // weakCompareAndSet可以重新 可以通过继承AtomicReference重写此方法 public boolean weakCompareAndSet(V expect, V update) { return unsafe.compareAndSwapObject(this, valueOffset, expect, update); } void lazySet(V newValue) // 该方法不能保证newValue修改立刻被其他线程看到 // putOrderedObject是putObjectVolatile的延迟实现 public final void lazySet(V newValue) { unsafe.putOrderedObject(this, valueOffset, newValue); } V getAndSet(V newValue) // 原子方式更新value 并返回旧值 public final V getAndSet(V newValue) { return unsafe.getAndSetObject(this, valueOffset, newValue); } V getAndUpdate(UnaryOperator updateFunction) // 对旧值进行一元操作 返回旧值 public final V getAndUpdate(UnaryOperator updateFunction) { V prev, next; do { prev = get(); next = updateFunction.apply(prev); } while (!compareAndSet(prev, next)); return prev; } V updateAndGet(UnaryOperator updateFunction) // 对旧值进行一元操作 返回新值 public final V updateAndGet(UnaryOperator updateFunction) { V prev, next; do { prev = get(); next = updateFunction.apply(prev); } while (!compareAndSet(prev, next)); return next; } V getAndAccumulate(V x, BinaryOperator accumulatorFunction) // 对旧值进行二元操作 返回旧值 public final V getAndAccumulate(V x, BinaryOperator accumulatorFunction) { V prev, next; do { prev = get(); next = accumulatorFunction.apply(prev, x); } while (!compareAndSet(prev, next)); return prev; } V accumulateAndGet(V x, BinaryOperator accumulatorFunction) // 对旧值进行二元操作 返回新值 public final V accumulateAndGet(V x, BinaryOperator accumulatorFunction) { V prev, next; do { prev = get(); next = accumulatorFunction.apply(prev, x); } while (!compareAndSet(prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicMarkableReference.html":{"url":"content/java/util/concurrent/atomic/AtomicMarkableReference.html","title":"AtomicMarkableReference","keywords":"","body":"AtomicMarkableReference 可以用原子方式更新的对象引用及一个boolean标记 构造方法 AtomicMarkableReference(V initialRef, boolean initialMark) 静态内部类 private static class Pair { final T reference; // 引用 final boolean mark; // 更新标记 private Pair(T reference, boolean mark) { this.reference = reference; this.mark = mark; } // builder构建方法 static Pair of(T reference, boolean mark) { return new Pair(reference, mark); } } 方法 V getReference() // 获得当前引用 public V getReference() { return pair.reference; } boolean isMarked() // 获得引用标记 public boolean isMarked() { return pair.mark; } V get(boolean[] markHolder) // 获得当前引用及标记 // markHolder[0]为当前标记 public V get(boolean[] markHolder) { Pair pair = this.pair; markHolder[0] = pair.mark; return pair.reference; } void set(V newReference, boolean newMark) // 设置引用和标记为给定值 非原子操作 public void set(V newReference, boolean newMark) { Pair current = pair; // 引用和标记其中一个不一致 则设置 if (newReference != current.reference || newMark != current.mark) this.pair = Pair.of(newReference, newMark); } boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) public boolean compareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) { Pair current = pair; return expectedReference == current.reference && // 引用一致 expectedMark == current.mark && // 标记一致 ((newReference == current.reference && newMark == current.mark) || // 新引用和新标记未更改 // 否则cas更新引用和标记 casPair(current, Pair.of(newReference, newMark))); } // cas更新引用标记对 private boolean casPair(Pair cmp, Pair val) { return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); } public boolean weakCompareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) // 同compareAndSet方法 public boolean weakCompareAndSet(V expectedReference, V newReference, boolean expectedMark, boolean newMark) { return compareAndSet(expectedReference, newReference, expectedMark, newMark); } boolean attemptMark(V expectedReference, boolean newMark) // 尝试标记 // 标记成功返回true 否则返回false public boolean attemptMark(V expectedReference, boolean newMark) { Pair current = pair; return expectedReference == current.reference && (newMark == current.mark || casPair(current, Pair.of(expectedReference, newMark))); } "},"content/java/util/concurrent/atomic/AtomicStampedReference.html":{"url":"content/java/util/concurrent/atomic/AtomicStampedReference.html","title":"AtomicStampedReference","keywords":"","body":"AtomicStampedReference 可以用原子方式更新的对象引用及一个int版本号 构造方法 AtomicStampedReference(V initialRef, int initialMark) 静态内部类 private static class Pair { final T reference; // 引用 final int stamp; // 版本号 private Pair(T reference, int stamp) { this.reference = reference; this.stamp = stamp; } // builder构造方法 static Pair of(T reference, int stamp) { return new Pair(reference, stamp); } } 方法 V getReference() // 获得当前引用 public V getReference() { return pair.reference; } int getStamp() // 获得当前版本号 public int getStamp() { return pair.stamp; } V get(int[] stampHolder) // 获得当前引用及版本号 // stampHolder[0]为当前版本号 public V get(int[] stampHolder) { Pair pair = this.pair; stampHolder[0] = pair.stamp; return pair.reference; } void set(V newReference, int newStamp) // 设置引用和版本号为给定值 非原子操作 public void set(V newReference, int newStamp) { Pair current = pair; // 引用和版本号其中一个不一致 则设置 if (newReference != current.reference || newStamp != current.stamp) this.pair = Pair.of(newReference, newStamp); } boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair current = pair; return expectedReference == current.reference && // 引用一致 expectedStamp == current.stamp && // 版本号一直 ((newReference == current.reference && newStamp == current.stamp) || // 新引用和新版本号未更改 // 否则 cas更新引用版本号对 casPair(current, Pair.of(newReference, newStamp))); } // cas更新引用版本号对 private boolean casPair(Pair cmp, Pair val) { return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); } public boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) // 同compareAndSet方法 public boolean weakCompareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { return compareAndSet(expectedReference, newReference, expectedStamp, newStamp); } boolean attemptStamp(V expectedReference, int newStamp) // 尝试标记 // 标记成功返回true 否则返回false public boolean attemptStamp(V expectedReference, int newStamp) { Pair current = pair; return expectedReference == current.reference && (newStamp == current.stamp || casPair(current, Pair.of(expectedReference, newStamp))); } "},"content/java/util/concurrent/atomic/AtomicIntegerArray.html":{"url":"content/java/util/concurrent/atomic/AtomicIntegerArray.html","title":"AtomicIntegerArray","keywords":"","body":"AtomicIntegerArray 可以原子更新的int[]，修改指定索引的值和AtomicInteger的方法类似 静态域及块 // Unsafe实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // int数组的第一个元素的偏移量 private static final int base = unsafe.arrayBaseOffset(int[].class); // 用于定位数组元素内存位置的位移 private static final int shift; // int[] private final int[] array; static { // 获得数组第一个元素的字节大小 int scale = unsafe.arrayIndexScale(int[].class); if ((scale & (scale - 1)) != 0) throw new Error(\"data type scale not a power of two\"); // Integer.numberOfLeadingZeros(scale)返回高位0的个数 // 获得每个元素之间的位移 shift = 31 - Integer.numberOfLeadingZeros(scale); } 构造方法 AtomicIntegerArray(int length) 根据指定length初始化数组 AtomicIntegerArray(int[] array) 根据给定array初始化数组 方法 int length() // 返回数组元素个数 public final int length() { return array.length; } int get(int i) // 获得数组给定索引i的值 public final int get(int i) { return getRaw(checkedByteOffset(i)); } // check索引 private long checkedByteOffset(int i) { if (i = array.length) throw new IndexOutOfBoundsException(\"index \" + i); return byteOffset(i); } // 计算给定索引i的偏移量 private static long byteOffset(int i) { return ((long) i void set(int i, int newValue) // 更新数组索引i的值为newValue public final void set(int i, int newValue) { unsafe.putIntVolatile(array, checkedByteOffset(i), newValue); } void lazySet(int i, int newValue) // 更新数组索引i的值为newValue 不能保证被其他线程实时看到最新值 public final void lazySet(int i, int newValue) { unsafe.putOrderedInt(array, checkedByteOffset(i), newValue); } int getAndSet(int i, int newValue) // 设置数组索引i的值为newValue 并返回该位置的旧值 public final int getAndSet(int i, int newValue) { return unsafe.getAndSetInt(array, checkedByteOffset(i), newValue); } boolean compareAndSet(int i, int expect, int update) // 比较数组索引i的值是否为expect 若是更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(int i, int expect, int update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } // 比较数组偏移量offset的值是否为expect 若是更新为update // 更新成功返回true 否则返回false private boolean compareAndSetRaw(long offset, int expect, int update) { return unsafe.compareAndSwapInt(array, offset, expect, update); } boolean weakCompareAndSet(int i, int expect, int update) // 跟compareAndSet一致 public final boolean weakCompareAndSet(int i, int expect, int update) { return compareAndSet(i, expect, update); } int getAndAdd(int i, int delta) // 将数组索引i的值设置为i+delta 并返回旧值 public final int getAndAdd(int i, int delta) { return unsafe.getAndAddInt(array, checkedByteOffset(i), delta); } int addAndGet(int i, int delta) // 将数组索引i的值设置为i+delta 并返回新值 public final int addAndGet(int i, int delta) { // 见getAndAdd()方法 return getAndAdd(i, delta) + delta; } int getAndIncrement(int i) // 数组索引i的值进行i++操作 返回递增前的值 public final int getAndIncrement(int i) { return getAndAdd(i, 1); } int incrementAndGet(int i) // 数组索引i的值进行++i操作 返回递增后的值 public final int incrementAndGet(int i) { return getAndAdd(i, 1) + 1; } int getAndDecrement(int i) // 数组索引i的值进行i--操作 返回递减前的值 public final int getAndDecrement(int i) { return getAndAdd(i, -1); } int decrementAndGet(int i) // 数组索引i的值进行--i操作 返回递减前后值 public final int decrementAndGet(int i) { return getAndAdd(i, -1) - 1; } int getAndUpdate(int i, IntUnaryOperator updateFunction) // 数组索引i的值进行一元操作 返回操作前的值 public final int getAndUpdate(int i, IntUnaryOperator updateFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); // 一元操作方法 next = updateFunction.applyAsInt(prev); } while (!compareAndSetRaw(offset, prev, next)); return prev; } int updateAndGet(int i, IntUnaryOperator updateFunction) // 数组索引i的值进行一元操作 返回操作后的值 public final int updateAndGet(int i, IntUnaryOperator updateFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); next = updateFunction.applyAsInt(prev); } while (!compareAndSetRaw(offset, prev, next)); return next; } int getAndAccumulate(int i, int x, IntBinaryOperator accumulatorFunction) // 数组索引i的值进行二元操作 返回操作前的值 public final int getAndAccumulate(int i, int x, IntBinaryOperator accumulatorFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSetRaw(offset, prev, next)); return prev; } int accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction) // 数组索引i的值进行二元操作 返回操作后的值 public final int accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSetRaw(offset, prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicLongArray.html":{"url":"content/java/util/concurrent/atomic/AtomicLongArray.html","title":"AtomicLongArray","keywords":"","body":"AtomicLongArray 可以原子更新的long[]，修改指定索引的值和AtomicLong的方法类似 静态域及块 // Unsafe实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // long数组的第一个元素的偏移量 // 可以使用Unsafe.ARRAY_LONG_BASE_OFFSET private static final int base = unsafe.arrayBaseOffset(long[].class); // 用于定位数组元素内存位置的位移 private static final int shift; // long[] private final long[] array; static { // 获得数组第一个元素的字节大小 // 可以使用Unsafe.ARRAY_LONG_INDEX_SCALE int scale = unsafe.arrayIndexScale(long[].class); if ((scale & (scale - 1)) != 0) throw new Error(\"data type scale not a power of two\"); // Integer.numberOfLeadingZeros(scale)返回高位0的个数 // 获得每个元素之间的位移 shift = 31 - Integer.numberOfLeadingZeros(scale); } 构造方法 AtomicLongArray(int length) 根据指定length初始化数组 AtomicLongArray(long[] array) 根据给定array初始化数组 方法 int length() // 返回数组元素个数 public final int length() { return array.length; } long get(int i) // 获得数组给定索引i的值 public final long get(int i) { return getRaw(checkedByteOffset(i)); } // check索引 private long checkedByteOffset(int i) { if (i = array.length) throw new IndexOutOfBoundsException(\"index \" + i); return byteOffset(i); } // 计算给定索引i的偏移量 private static long byteOffset(int i) { return ((long) i void set(int i, long newValue) // 更新数组索引i的值为newValue public final void set(int i, long newValue) { unsafe.putLongVolatile(array, checkedByteOffset(i), newValue); } void lazySet(int i, long newValue) // 更新数组索引i的值为newValue 不能保证被其他线程实时看到最新值 public final void lazySet(int i, long newValue) { unsafe.putOrderedLong(array, checkedByteOffset(i), newValue); } long getAndSet(int i, long newValue) // 设置数组索引i的值为newValue 并返回该位置的旧值 public final long getAndSet(int i, long newValue) { return unsafe.getAndSetLong(array, checkedByteOffset(i), newValue); } boolean compareAndSet(int i, long expect, long update) // 比较数组索引i的值是否为expect 若是更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(int i, long expect, long update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } // 比较数组偏移量offset的值是否为expect 若是更新为update // 更新成功返回true 否则返回false private boolean compareAndSetRaw(long offset, long expect, long update) { return unsafe.compareAndSwapLong(array, offset, expect, update); } boolean weakCompareAndSet(int i, long expect, long update) // 跟compareAndSet一致 public final boolean weakCompareAndSet(int i, long expect, long update) { return compareAndSet(i, expect, update); } long getAndAdd(int i, long delta) // 将数组索引i的值设置为i+delta 并返回旧值 public final long getAndAdd(int i, long delta) { return unsafe.getAndAddInt(array, checkedByteOffset(i), delta); } long addAndGet(int i, long delta) // 将数组索引i的值设置为i+delta 并返回新值 public final long addAndGet(int i, long delta) { // 见getAndAdd()方法 return getAndAdd(i, delta) + delta; } int getAndIncrement(int i) // 数组索引i的值进行i++操作 返回递增前的值 public final int getAndIncrement(int i) { return getAndAdd(i, 1); } int incrementAndGet(int i) // 数组索引i的值进行++i操作 返回递增后的值 public final int incrementAndGet(int i) { return getAndAdd(i, 1) + 1; } int getAndDecrement(int i) // 数组索引i的值进行i--操作 返回递减前的值 public final int getAndDecrement(int i) { return getAndAdd(i, -1); } int decrementAndGet(int i) // 数组索引i的值进行--i操作 返回递减前后值 public final int decrementAndGet(int i) { return getAndAdd(i, -1) - 1; } long getAndUpdate(int i, LongUnaryOperator updateFunction) // 数组索引i的值进行一元操作 返回操作前的值 public final long getAndUpdate(int i, LongUnaryOperator updateFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); // 一元操作方法 next = updateFunction.applyAsInt(prev); } while (!compareAndSetRaw(offset, prev, next)); return prev; } long updateAndGet(int i, LongUnaryOperator updateFunction) // 数组索引i的值进行一元操作 返回操作后的值 public final long updateAndGet(int i, LongUnaryOperator updateFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); next = updateFunction.applyAsInt(prev); } while (!compareAndSetRaw(offset, prev, next)); return next; } long getAndAccumulate(int i, long x, LongBinaryOperator accumulatorFunction) // 数组索引i的值进行二元操作 返回操作前的值 public final long getAndAccumulate(int i, long x, LongBinaryOperator accumulatorFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSetRaw(offset, prev, next)); return prev; } long accumulateAndGet(int i, long x, LongBinaryOperator accumulatorFunction) // 数组索引i的值进行二元操作 返回操作后的值 public final long accumulateAndGet(int i, long x, LongBinaryOperator accumulatorFunction) { long offset = checkedByteOffset(i); int prev, next; do { prev = getRaw(offset); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSetRaw(offset, prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicReferenceArray.html":{"url":"content/java/util/concurrent/atomic/AtomicReferenceArray.html","title":"AtomicReferenceArray","keywords":"","body":"AtomicReferenceArray 可以原子更新的Object[]，修改指定索引的值和AtomicReference的方法类似 静态域及块 // Unsafe实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // Object数组第一个元素的偏移量 private static final int base; // 用于定位数组元素内存位置的位移 private static final int shift; // 数组相对于对象内存地址的偏移量 private static final long arrayFieldOffset; // Object[] private final Object[] array; // must have exact type Object[] static { try { // Unsafe实例 unsafe = Unsafe.getUnsafe(); // 通过AtomicReferenceArray字段获得数组相对的偏移量 arrayFieldOffset = unsafe.objectFieldOffset (AtomicReferenceArray.class.getDeclaredField(\"array\")); // 数组第一个元素的偏移量 可以用Unsafe.ARRAY_OBJECT_BASE_OFFSET代替 base = unsafe.arrayBaseOffset(Object[].class); // 数组元素字节大小 可以用Unsafe.ARRAY_OBJECT_INDEX_SCALE代替 int scale = unsafe.arrayIndexScale(Object[].class); if ((scale & (scale - 1)) != 0) throw new Error(\"data type scale not a power of two\"); // 获得每个元素之间的位移 shift = 31 - Integer.numberOfLeadingZeros(scale); } catch (Exception e) { throw new Error(e); } } 构造方法 AtomicReferenceArray(int length) 根据指定length初始化数组 AtomicReferenceArray(E[] array) 根据给定array初始化数组 方法 int length() // 返回数组元素个数 public final int length() { return array.length; } E get(int i) // 获得数组给定索引i的值 public final long get(int i) { return getRaw(checkedByteOffset(i)); } // check索引 private long checkedByteOffset(int i) { if (i = array.length) throw new IndexOutOfBoundsException(\"index \" + i); return byteOffset(i); } // 计算给定索引i的偏移量 private static long byteOffset(int i) { return ((long) i void set(int i, E newValue) // 更新数组索引i的值为newValue public final void set(int i, E newValue) { unsafe.putObjectVolatile(array, checkedByteOffset(i), newValue); } void lazySet(int i, E newValue) // 更新数组索引i的值为newValue 不能保证被其他线程实时看到最新值 public final void lazySet(int i, E newValue) { unsafe.putOrderedObject(array, checkedByteOffset(i), newValue); } E getAndSet(int i, E newValue) // 设置数组索引i的值为newValue 并返回该位置的旧值 public final E getAndSet(int i, E newValue) { return (E)unsafe.getAndSetObject(array, checkedByteOffset(i), newValue); } boolean compareAndSet(int i, E expect, E update) // 比较数组索引i的值是否为expect 若是更新为update // 更新成功返回true 否则返回false public final boolean compareAndSet(int i, E expect, E update) { return compareAndSetRaw(checkedByteOffset(i), expect, update); } // 比较数组偏移量offset的值是否为expect 若是更新为update // 更新成功返回true 否则返回false private boolean compareAndSetRaw(long offset, E expect, E update) { return unsafe.compareAndSwapObject(array, offset, expect, update); } boolean weakCompareAndSet(int i, E expect, E update) // 跟compareAndSet一致 public final boolean weakCompareAndSet(int i, E expect, E update) { return compareAndSet(i, expect, update); } E getAndUpdate(int i, UnaryOperator updateFunction) // 数组索引i的值进行一元操作 返回操作前的值 public final E getAndUpdate(int i, UnaryOperator updateFunction) { long offset = checkedByteOffset(i); E prev, next; do { prev = getRaw(offset); next = updateFunction.apply(prev); } while (!compareAndSetRaw(offset, prev, next)); return prev; } E updateAndGet(int i, UnaryOperator updateFunction) // 数组索引i的值进行一元操作 返回操作后的值 public final E updateAndGet(int i, UnaryOperator updateFunction) { long offset = checkedByteOffset(i); E prev, next; do { prev = getRaw(offset); next = updateFunction.apply(prev); } while (!compareAndSetRaw(offset, prev, next)); return next; } E getAndAccumulate(int i, E x, BinaryOperator accumulatorFunction) // 数组索引i的值进行二元操作 返回操作前的值 public final E getAndAccumulate(int i, E x, BinaryOperator accumulatorFunction) { long offset = checkedByteOffset(i); E prev, next; do { prev = getRaw(offset); next = accumulatorFunction.apply(prev, x); } while (!compareAndSetRaw(offset, prev, next)); return prev; } E accumulateAndGet(int i, E x, BinaryOperator accumulatorFunction) // 数组索引i的值进行二元操作 返回操作后的值 public final E accumulateAndGet(int i, E x, BinaryOperator accumulatorFunction) { long offset = checkedByteOffset(i); E prev, next; do { prev = getRaw(offset); next = accumulatorFunction.apply(prev, x); } while (!compareAndSetRaw(offset, prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html":{"url":"content/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html","title":"AtomicIntegerFieldUpdater","keywords":"","body":"AtomicIntegerFieldUpdater 原子更新对象的int字段，字段的类型必须为int，且必须为volatile修饰。AtomicIntegerFieldUpdater 是一个抽象类，通过一个工厂方法获得该抽象类子类的实例。 构造方法 protected AtomicIntegerFieldUpdater() 受保护的构造方法 使用下面工厂方法代替 public static AtomicIntegerFieldUpdater newUpdater(Class tclass, String fieldName) { return new AtomicIntegerFieldUpdaterImpl (tclass, fieldName, Reflection.getCallerClass()); } 静态内部类 private static class AtomicIntegerFieldUpdaterImpl extends AtomicIntegerFieldUpdater { // Unsafe实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // 字段偏移量 private final long offset; // 字段所属Class private final Class tclass; // 调用者Class private final Class cclass; AtomicIntegerFieldUpdaterImpl(final Class tclass, final String fieldName, final Class caller) { final Field field; final int modifiers; try { // AccessController 根据当前有效的安全策略决定是否允许或拒绝对关键资源的访问 // 根据字段名获得Field field = AccessController.doPrivileged( new PrivilegedExceptionAction() { public Field run() throws NoSuchFieldException { return tclass.getDeclaredField(fieldName); } }); // 获得字段修饰符 modifiers = field.getModifiers(); // 验证caller与tclass、tclass与字段之间的访问权限 sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); ClassLoader cl = tclass.getClassLoader(); ClassLoader ccl = caller.getClassLoader(); if ((ccl != null) && (ccl != cl) && ((cl == null) || !isAncestor(cl, ccl))) { sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); } } catch (PrivilegedActionException pae) { throw new RuntimeException(pae.getException()); } catch (Exception ex) { throw new RuntimeException(ex); } Class fieldt = field.getType(); // 字段必须为int类型 if (fieldt != int.class) throw new IllegalArgumentException(\"Must be integer type\"); // 字段必须为volatile修饰 if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException(\"Must be volatile type\"); this.cclass = (Modifier.isProtected(modifiers) && caller != tclass) ? caller : null; this.tclass = tclass; // 字段偏移量 offset = unsafe.objectFieldOffset(field); } // 校验first ClassLoader是否是second ClassLoader的父类 private static boolean isAncestor(ClassLoader first, ClassLoader second) { ClassLoader acl = first; do { acl = acl.getParent(); if (second == acl) { return true; } } while (acl != null); return false; } // 访问权限校验 private void fullCheck(T obj) { // 确保obj是tclass的实例 if (!tclass.isInstance(obj)) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); } // 比较实例字段的值并替换 public boolean compareAndSet(T obj, int expect, int update) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.compareAndSwapInt(obj, offset, expect, update); } // 跟compareAndSet一致 public boolean weakCompareAndSet(T obj, int expect, int update) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.compareAndSwapInt(obj, offset, expect, update); } // putIntVolatile保证set后立刻被其他线程看到 public void set(T obj, int newValue) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); unsafe.putIntVolatile(obj, offset, newValue); } // putIntVolatile的延迟实现 不能保证set后立刻被其他线程看到 public void lazySet(T obj, int newValue) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); unsafe.putOrderedInt(obj, offset, newValue); } // 获得int字段最新值 public final int get(T obj) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.getIntVolatile(obj, offset); } // 设置int字段为新值 返回旧值 public int getAndSet(T obj, int newValue) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.getAndSetInt(obj, offset, newValue); } // int字段做原子i++操作 返回旧值 public int getAndIncrement(T obj) { return getAndAdd(obj, 1); } // int字段做原子i--操作 返回旧值 public int getAndDecrement(T obj) { return getAndAdd(obj, -1); } // int字段增加delta 返回旧值 public int getAndAdd(T obj, int delta) { if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.getAndAddInt(obj, offset, delta); } // int字段做原子++i 返回新值 public int incrementAndGet(T obj) { return getAndAdd(obj, 1) + 1; } // int字段做原子--i 返回新值 public int decrementAndGet(T obj) { return getAndAdd(obj, -1) - 1; } // int字段增加delta 返回新值 public int addAndGet(T obj, int delta) { return getAndAdd(obj, delta) + delta; } // 确保obj的Class能访问 private void ensureProtectedAccess(T obj) { // 如果obj是cclass的实例 if (cclass.isInstance(obj)) { return; } throw new RuntimeException( new IllegalAccessException(\"Class \" + cclass.getName() + \" can not access a protected member of class \" + tclass.getName() + \" using an instance of \" + obj.getClass().getName() ) ); } } 方法 抽象方法均由静态内部类AtomicIntegerFieldUpdaterImpl实现，其他为AtomicIntegerFieldUpdater实现 抽象方法 // 见AtomicIntegerFieldUpdaterImpl中compareAndSet方法 public abstract boolean compareAndSet(T obj, int expect, int update); // 见AtomicIntegerFieldUpdaterImpl中weakCompareAndSet方法 public abstract boolean weakCompareAndSet(T obj, int expect, int update); // 见AtomicIntegerFieldUpdaterImpl中set方法 public abstract void set(T obj, int newValue); // 见AtomicIntegerFieldUpdaterImpl中lazySet方法 public abstract void lazySet(T obj, int newValue); // 见AtomicIntegerFieldUpdaterImpl中get方法 public abstract int get(T obj); int getAndSet(T obj, int newValue) // 修改int字段值 返回旧值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndSetInt实现 public int getAndSet(T obj, int newValue) { int prev; do { // 子类get实现 prev = get(obj); } while (!compareAndSet(obj, prev, newValue)); return prev; } int getAndIncrement(T obj) // 原子i++操作 返回旧值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndAddInt实现 public int getAndIncrement(T obj) { int prev, next; do { prev = get(obj); next = prev + 1; } while (!compareAndSet(obj, prev, next)); return prev; } int getAndDecrement(T obj) // 原子i--操作 返回旧值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndAddInt实现 public int getAndDecrement(T obj) { int prev, next; do { prev = get(obj); next = prev - 1; } while (!compareAndSet(obj, prev, next)); return prev; } int getAndAdd(T obj, int delta) // 原子i+n操作 返回旧值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndAddInt实现 public int getAndAdd(T obj, int delta) { int prev, next; do { prev = get(obj); next = prev + delta; } while (!compareAndSet(obj, prev, next)); return prev; } int incrementAndGet(T obj) // 原子++i操作 返回新值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndAddInt实现 public int incrementAndGet(T obj) { int prev, next; do { prev = get(obj); next = prev + 1; } while (!compareAndSet(obj, prev, next)); return next; } int decrementAndGet(T obj) // 原子--i操作 返回新值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndAddInt实现 public int decrementAndGet(T obj) { int prev, next; do { prev = get(obj); next = prev - 1; } while (!compareAndSet(obj, prev, next)); return next; } int addAndGet(T obj, int delta) // 原子i+n操作 返回新值 // 默认cas实现 // AtomicIntegerFieldUpdaterImpl已经重写此方法 使用getAndAddInt实现 public int addAndGet(T obj, int delta) { int prev, next; do { prev = get(obj); next = prev + delta; } while (!compareAndSet(obj, prev, next)); return next; } int getAndUpdate(T obj, IntUnaryOperator updateFunction) // int字段进行一元操作 返回旧值 // cas实现 public final int getAndUpdate(T obj, IntUnaryOperator updateFunction) { int prev, next; do { prev = get(obj); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(obj, prev, next)); return prev; } int updateAndGet(T obj, IntUnaryOperator updateFunction) // int字段进行一元操作 返回新值 // cas实现 public final int updateAndGet(T obj, IntUnaryOperator updateFunction) { int prev, next; do { prev = get(obj); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(obj, prev, next)); return next; } int getAndAccumulate(T obj, int x, IntBinaryOperator accumulatorFunction) // int字段进行二元操作 返回旧值 // cas实现 public final int getAndAccumulate(T obj, int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(obj); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(obj, prev, next)); return prev; } int accumulateAndGet(T obj, int x, IntBinaryOperator accumulatorFunction) // int字段进行二元操作 返回新值 // cas实现 public final int accumulateAndGet(T obj, int x, IntBinaryOperator accumulatorFunction) { int prev, next; do { prev = get(obj); next = accumulatorFunction.applyAsInt(prev, x); } while (!compareAndSet(obj, prev, next)); return next; } "},"content/java/util/concurrent/atomic/AtomicLongFieldUpdater.html":{"url":"content/java/util/concurrent/atomic/AtomicLongFieldUpdater.html","title":"AtomicLongFieldUpdater","keywords":"","body":"AtomicLongFieldUpdater "},"content/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html":{"url":"content/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html","title":"AtomicReferenceFieldUpdater","keywords":"","body":"AtomicReferenceFieldUpdater "},"content/java/util/concurrent/BlockingQueue/":{"url":"content/java/util/concurrent/BlockingQueue/","title":"BlockingQueue","keywords":"","body":"BlockingQueue BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。 阻塞队列有四种行为无法操作：入队时队列满了或者出队时队列为空 行为 描述 enqueue dequeue 抛异常 无法操作时抛出异常 add(o) remove() 返回特定值 无法操作时返回一个特定值，通常为true/false offer(o) poll() 阻塞 无法操作时会一直阻塞，直到可以正常操作 put(o) take() 超时 无法操作时会阻塞不超过给定超时时间，返回一个特定值 offer(o, timeout, timeunit) poll(timeout, timeunit) BlockingQueue由来及实现 看不清楚新标签中打开大图查看 "},"content/java/util/concurrent/BlockingQueue/ArrayBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/ArrayBlockingQueue.html","title":"ArrayBlockingQueue","keywords":"","body":"ArrayBlockingQueue ArrayBlockingQueue是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。 有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。 你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了 (因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 源码分析 初始化必须指定容量 可选是否为公平锁或者通过一个现有集合(Collection)初始化 ArrayBlockingQueue(int capacity) ArrayBlockingQueue(int capacity, boolean fair) ArrayBlockingQueue(int capacity, boolean fair, Collection c) 属性 // 存储队列元素的数组，是个循环数组 final Object[] items; // 拿数据的索引，用于take，poll，peek，remove方法 int takeIndex; // 放数据的索引，用于put，offer，add方法 int putIndex; // 元素个数 int count; // 可重入锁 final ReentrantLock lock; // notEmpty条件对象，由lock创建 private final Condition notEmpty; // notFull条件对象，由lock创建 private final Condition notFull; 方法 添加元素 boolean offer(E e) public boolean offer(E e) { checkNotNull(e); // null元素抛出NullPointerException final ReentrantLock lock = this.lock; lock.lock(); // 加锁 try { if (count == items.length) return false; // 队列满了返回false else { enqueue(e); // 入队 return true; } } finally { lock.unlock(); // 释放锁 } } private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) // 如果put索引满了 移动到0 putIndex = 0; count++; // 队列元素个数增加 // 使用条件对象notEmpty通知，比如使用take方法的时候队列里没有数据，被阻塞。 // 这个时候队列insert了一条数据，需要调用signal进行通知 notEmpty.signal(); } boolean offer(E e, long timeout, TimeUnit unit) public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); // 将TimeUnit转为纳秒 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) { // 若果队列满了 if (nanos boolean add(E e) public boolean add(E e) { if (offer(e)) // 队列未满 直接添加元素 见上offer方法 return true; else // 否则抛出队列满的异常 throw new IllegalStateException(\"Queue full\"); } void put(E e) public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) notFull.await(); // 如果队列满了阻塞挂起 释放锁 enqueue(e); } finally { lock.unlock(); } } 移除元素 E poll() public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { // 队列空返回null 否者进行出队操作 return (count == 0) ? null : dequeue(); } finally { lock.unlock(); } } private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; // 删除take索引位置的元素 E x = (E) items[takeIndex]; items[takeIndex] = null; // take索引后移 并判断是否需要移动到起始位置 if (++takeIndex == items.length) takeIndex = 0; count--; // 重置迭代器如果take索引回到起始位置 // 如果队列为空 将迭代器置为null if (itrs != null) itrs.elementDequeued(); // 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。 // 这个时候消费了一条数据，队列没满了，就需要调用signal进行通知 notFull.signal(); return x; } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; // 如果当前线程被中断 抛出InterruptedException lock.lockInterruptibly(); try { while (count == 0) { if (nanos E remove() public E remove() { E x = poll(); // 见poll方法 if (x != null) return x; else throw new NoSuchElementException(); } boolean remove(Object o) // 删除一个指定元素 public boolean remove(Object o) { if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { if (count > 0) { // put索引 final int putIndex = this.putIndex; // take索引 int i = takeIndex; // 从take索引遍历到put索引 如果找到删除指定索引位置元素 // 否则 返回false do { if (o.equals(items[i])) { removeAt(i); return true; } if (++i == items.length) i = 0; } while (i != putIndex); } return false; } finally { lock.unlock(); } } void removeAt(final int removeIndex) { // assert lock.getHoldCount() == 1; // assert items[removeIndex] != null; // assert removeIndex >= 0 && removeIndex E take() public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); // 如果队列为空 阻塞到队列非空 return dequeue(); // 出队操作 见E poll() } finally { lock.unlock(); } } 总结 ArrayBlockingQueue底层是一个循环的数组，使用一个重入锁和这个锁生成的两个条件对象进行并发控制。 其他方法都会加锁比如contains、toArray、drainTo、clear、toString。 "},"content/java/util/concurrent/BlockingQueue/LinkedBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/LinkedBlockingQueue.html","title":"LinkedBlockingQueue","keywords":"","body":"LinkedBlockingQueue LinkedBlockingQueue是一个基于单链表的无界阻塞队列，它跟ArrayBlockingQueue一样都是通过使用ReentrantLock来保证线程安全的。 但是LinkedBlockingQueue有两把锁，即put重入锁和take重入锁。ArrayBlockingQueue中put和take只能有一个被执行，不允许并行执行。 LinkedBlockingQueue允许take和put并行执行，当然只能有1个线程各自运行。 LinkedBlockingQueue不允许null值，也不强制我们指定队列得初始容量，默认的容量为Integer.MAX_VALUE。 源码分析 初始化若指定容量以指定为准，否则容量为Integer.MAX_VALUE，也可以使用一个现有集合来初始化 LinkedBlockingQueue() LinkedBlockingQueue(int capacity) LinkedBlockingQueue(Collection c) 属性 // 链表容量 private final int capacity; // 当前队列元素数量 // 由于有take、put两把锁 需要使用AtomicInteger来保证队列元素数量线程安全 private final AtomicInteger count = new AtomicInteger(); // 链表头 transient Node head; // 链表尾 private transient Node last; // take重入锁 private final ReentrantLock takeLock = new ReentrantLock(); // 非空条件 由take重入锁创建 private final Condition notEmpty = takeLock.newCondition(); // put重入锁 private final ReentrantLock putLock = new ReentrantLock(); // 非满条件 由put重入锁创建 private final Condition notFull = putLock.newCondition(); // 链表节点 static class Node { E item; /** * One of: * - the real successor Node * - this Node, meaning the successor is head.next * - null, meaning there is no successor (this is the last node) */ Node next; Node(E x) { item = x; } } 方法 添加元素 boolean offer(E e) public boolean offer(E e) { // LinkedBlockingQueue不允许null if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; // 如果队列满了返回false if (count.get() == capacity) return false; int c = -1; Node node = new Node(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try { // 双重校验队列是否满 if (count.get() = 0; } private void enqueue(Node node) { // 入队的时候只在last尾节点添加元素 // Java是自右向左逐一赋值的，比如：A=B=C=0，首先给C赋值0，即C=0，然后B=C;最后A=B // 故此处为先将last.next地址指向node 即将head链表增加一个节点 // 再将last地址指向last.next 即last指向最后一个节点 last = last.next = node; } private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { notEmpty.signal(); } finally { takeLock.unlock(); } } boolean offer(E e, long timeout, TimeUnit unit) public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { // 跟offer(E e)方法的主要区别 // 等待给定timeout // 超时则返回false 否则进行入队操作 while (count.get() == capacity) { if (nanos (e)); c = count.getAndIncrement(); if (c + 1 boolean add(E e) public boolean add(E e) { if (offer(e)) // 见上offer(E e)方法 return true; else throw new IllegalStateException(\"Queue full\"); } void put(E e) public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node node = new Node(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ // 如果队列是满的 阻塞到队列非满 while (count.get() == capacity) { notFull.await(); } enqueue(node); c = count.getAndIncrement(); if (c + 1 移除元素 E poll() public E poll() { final AtomicInteger count = this.count; if (count.get() == 0) // 如果队列为空 直接返回null return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { if (count.get() > 0) { x = dequeue(); // 出队核心方法 c = count.getAndDecrement(); if (c > 1) notEmpty.signal(); } } finally { takeLock.unlock(); } // 和入队类似 如果在删除元素前队列是满的 // 此时c等于capacity 但实际元素个数只有capacity-1个 // 故唤醒put线程 可以进行入队操作 if (c == capacity) signalNotFull(); return x; } private E dequeue() { Node h = head; // 将h指向当前头结点 Node first = h.next; // 将first指向第二个节点 h.next = h; // help GC // h指向h后一个节点 head = first; // 将头结点指向第二个节点 E x = first.item; // 获得队首的元素 first.item = null; // 删除队首元素 return x; } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { // 等待timeout 超时返回null 否则删除元素 while (count.get() == 0) { if (nanos 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } E remove() public E remove() { E x = poll(); // 见上poll()方法 if (x != null) return x; else // 队列为空抛出异常 throw new NoSuchElementException(); } boolean remove(Object o) // 删除指定元素 public boolean remove(Object o) { if (o == null) return false; // 跟其他删除不同 这里加的是全锁即take、put锁 // 因为指定元素可能不在队首 fullyLock(); try { // 从head开始遍历 直到next不为null for (Node trail = head, p = trail.next; p != null; trail = p, p = p.next) { if (o.equals(p.item)) { // p为要删除节点 // trail为p的前一个节点 unlink(p, trail); return true; } } return false; } finally { fullyUnlock(); } } void unlink(Node p, Node trail) { // assert isFullyLocked(); // p.next is not changed, to allow iterators that are // traversing p to maintain their weak-consistency guarantee. p.item = null; // 移除节点元素 trail.next = p.next; // 连接移除节点前后节点 if (last == p) // 如果删除节点为队尾 last = trail; // 将last节点指向trail if (count.getAndDecrement() == capacity) // 删除元素前队列是满的 唤醒put线程 notFull.signal(); } E take() public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { // 如果队列为空 阻塞到队列为非空 while (count.get() == 0) { notEmpty.await(); } x = dequeue(); c = count.getAndDecrement(); if (c > 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } 总结 LinkedBlockingQueue底层是一个单链表，使用put锁、take锁和两锁生成的条件对象进行并发控制。 其他方法都会加全锁(即put、take锁)比如contains、toArray、drainTo、clear、toString。 "},"content/java/util/concurrent/BlockingQueue/PriorityBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/PriorityBlockingQueue.html","title":"PriorityBlockingQueue","keywords":"","body":"PriorityBlockingQueue "},"content/java/util/concurrent/BlockingQueue/DelayQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/DelayQueue.html","title":"DelayQueue","keywords":"","body":"DelayQueue DelayQueue对元素进行持有直到一个特定的延迟到期，不允许null元素且注入其中的元素必须实现java.util.concurrent.Delayed接口。 PriorityQueue是一个根据队列里元素某些属性排列先后的顺序队列，DelayQueue其实就是在每次往优先级队列中添加元素， 然后以元素的delay过期值作为排序的因素，以此来达到先过期的元素会排在队首，每次从队列里取出来都是最先过期的元素。 源码分析 DelayQueue是容量无界的最大为Integer.MAX_VALUE，默认容量为11，若容量不够以当前容量50%递增， 可以使用一个现有集合对象初始化。 DelayQueue() DelayQueue(Collection c)元素需要实现的接口Delayed public interface Delayed extends Comparable { /** * Returns the remaining delay associated with this object, in the * given time unit. * * @param unit the time unit * @return the remaining delay; zero or negative values indicate * that the delay has already elapsed */ long getDelay(TimeUnit unit); } 属性 // 重入锁 private final transient ReentrantLock lock = new ReentrantLock(); // 锁条件对象 private final Condition available = lock.newCondition(); // 根据delay时间排序的优先队列 private final PriorityQueue q = new PriorityQueue(); /** * Thread designated to wait for the element at the head of * the queue. This variant of the Leader-Follower pattern * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to * minimize unnecessary timed waiting. When a thread becomes * the leader, it waits only for the next delay to elapse, but * other threads await indefinitely. The leader thread must * signal some other thread before returning from take() or * poll(...), unless some other thread becomes leader in the * interim. Whenever the head of the queue is replaced with * an element with an earlier expiration time, the leader * field is invalidated by being reset to null, and some * waiting thread, but not necessarily the current leader, is * signalled. So waiting threads must be prepared to acquire * and lose leadership while waiting. */ // 用于优化阻塞通知的线程元素leader 用leader来减少不必要的等待时间 // private Thread leader = null; leader的作用? leader的主要作用用于减少不必要的阻塞时间，例如有多个消费者线程用take方法去取， 内部先加锁，然后每个线程都去peek第一个节点。如果leader不为空说明已经有线程在取了，设置当前线程阻塞。 如果为空说明没有其他线程去取这个节点，设置leader并等待delay延时到期，直到poll后结束循环。 方法 添加元素 boolean offer(E e) public boolean offer(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { q.offer(e); // 优先队列入队 if (q.peek() == e) { // 查看元素是否是优先队列队首 leader = null; // 设置leader为空 唤醒take线程 available.signal(); } return true; } finally { lock.unlock(); } } boolean offer(E e, long timeout, TimeUnit unit)同offer(E e)方法 因为队列没有容量限制故没有超时的offer方法 boolean add(E e)同offer(E e)方法 因为队列没有容量限制故没有抛出异常的add方法 void put(E e)同offer(E e)方法 因为队列没有容量限制故没有阻塞的put方法 移除元素 E poll() public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { E first = q.peek(); // 查看优先队队首 // 如果优先队列为空或队首delay时间为达到返回null if (first == null || first.getDelay(NANOSECONDS) > 0) return null; else return q.poll(); // 优先队列出队 } finally { lock.unlock(); } } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { E first = q.peek(); if (first == null) { // 当优先队列为空时 if (nanos 出队方法中为什么要释放first元素? 假如有线程A和B都来获取队首，如果线程A阻塞完毕，获取对象成功，出队完成。 这个对象理应被GC回收，但是他还被线程B持有着，GC链可达，所以不能回收这个first。 E remove() public E remove() { E x = poll(); // 见上poll()方法 if (x != null) return x; else throw new NoSuchElementException(); } boolean remove(Object o) public boolean remove(Object o) { final ReentrantLock lock = this.lock; lock.lock(); try { // 调用优先队列remove(Object o)方法 return q.remove(o); } finally { lock.unlock(); } } E take() public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { E first = q.peek(); if (first == null) // 如果队首为null 阻塞当前线程 available.await(); else { long delay = first.getDelay(NANOSECONDS); if (delay 总结 DelayQueue底层是一个优先队列(java.util.PriorityQueue)，使用一个重入锁和锁生成的条件对象进行并发控制。 toArray、drainTo、clear都加锁但contains、toString未加锁。 "},"content/java/util/concurrent/BlockingQueue/SynchronousQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/SynchronousQueue.html","title":"SynchronousQueue","keywords":"","body":"SynchronousQueue "},"content/javax/":{"url":"content/javax/","title":"javax","keywords":"","body":"javax包 也是java标准的一部分，但是没有包含在标准库中，一般属于标准库的扩展。通常属于某个特定领域，不是一般性的api。所以以扩展的方式提供api，以避免jdk的标准库过大。当然某些早期的javax，后来被并入到标准库中，所有也应该属于新版本JDK的标准库。比如jmx，java 5以前是以扩展方式提供，但是jdk5以后就做为标准库的一部分了，所有javax.management也是jdk5的标准库的一部分。 "},"content/sun/misc/Unsafe.html":{"url":"content/sun/misc/Unsafe.html","title":"Unsafe","keywords":"","body":"Unsafe Unsafe类在jdk源码的多个类中用到，这个类的提供了一些绕开JVM的更底层功能，基于它的实现可以提高效率。 但是，它是一把双刃剑：正如它的名字所预示的那样，它是Unsafe的，它所分配的内存需要手动free（不被GC回收）。 Unsafe类，提供了JNI某些功能的简单替代：确保高效性的同时，使事情变得更简单。 更多信息请前往API查看 本文参考地址 API Unsafe API的大部分方法都是native实现，它由105个方法组成，主要包括以下几类 属性 属性名 属性值 INVALID_FIELD_OFFSET -1 ARRAY_BOOLEAN_BASE_OFFSET Unsafe.arrayBaseOffset(boolean[].class) ARRAY_BYTE_BASE_OFFSET Unsafe.arrayBaseOffset(byte[].class) ARRAY_SHORT_BASE_OFFSET Unsafe.arrayBaseOffset(short[].class) ARRAY_CHAR_BASE_OFFSET Unsafe.arrayBaseOffset(char[].class) ARRAY_INT_BASE_OFFSET Unsafe.arrayBaseOffset(int[].class) ARRAY_LONG_BASE_OFFSET Unsafe.arrayBaseOffset(long[].class) ARRAY_FLOAT_BASE_OFFSET Unsafe.arrayBaseOffset(float[].class) ARRAY_DOUBLE_BASE_OFFSET Unsafe.arrayBaseOffset(double[].class) ARRAY_OBJECT_BASE_OFFSET Unsafe.arrayBaseOffset(Object[].class) ARRAY_BOOLEAN_INDEX_SCALE Unsafe.arrayIndexScale(boolean[].class) ARRAY_BYTE_INDEX_SCALE Unsafe.arrayIndexScale(byte[].class) ARRAY_SHORT_INDEX_SCALE Unsafe.arrayIndexScale(short[].class) ARRAY_CHAR_INDEX_SCALE Unsafe.arrayIndexScale(char[].class) ARRAY_INT_INDEX_SCALE Unsafe.arrayIndexScale(int[].class) ARRAY_LONG_INDEX_SCALE Unsafe.arrayIndexScale(long[].class) ARRAY_FLOAT_INDEX_SCALE Unsafe.arrayIndexScale(float[].class) ARRAY_DOUBLE_INDEX_SCALE Unsafe.arrayIndexScale(double[].class) ARRAY_OBJECT_INDEX_SCALE Unsafe.arrayIndexScale(Object[].class) ADDRESS_SIZE Unsafe.addressSize() Info 获得某些低级别的内存信息 int addressSize() 返回内存地址长度4或者8字节 取决于jvm内存多少 如果堆大于32G则为8字节 小一点的堆则为4字节 int pageSize() 内存页字节大小 Objects 提供Object和它的Field操纵方法 Object allocateInstance(Class cls) 绕过构造方法直接初始化实例对象且不会初始化属性 对象类型属性为null 基本类型为默认值 Class 提供Class和它的静态Field操纵方法 defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches) 定义一个匿名内部类 ClassLoader并不知道该类的存在 Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain) 定义一个Class跳过安全检查 void ensureClassInitialized(Class c) 确保Class已经初始化 int fieldOffset(Field f) Deprecated 获得一个字段的偏移量使用staticFieldOffset和objectFieldOffset代替 byte getByte(long address) 获得内存地址指向的byte该类型方法表示获得给定内存地址指向的数据 对应的除了boolean、Object还有 char getChar(long address) double getDouble(long address) float getFloat(long address) int getInt(long address) long getLong(long address) short getShort(long address) void putByte(long address, byte x) 设置内存地址address指向的byte为x该类型方法表示设置内存地址address指向的数据为x 对应的除了boolean、Object还有 void putChar(long address, char x) void putDouble(long address, double x) void putFloat(long address, float x) void putInt(long address, int x) void putLong(long address, long x) void putShort(long address, short x) byte getByte(Object o, long offset) 获得给定对象内存地址偏移量为offset的byte该类型方法表示获得给定对象内存地址偏移量为offset的数据 boolean getBoolean(Object o, long offset) char getChar(Object o, long offset) double getDouble(Object o, long offset) float getFloat(Object o, long offset) int getInt(Object o, long offset) long getLong(Object o, long offset) Object getObject(Object o, long offset) short getShort(Object o, long offset) void putByte(Object o, long offset, byte x) 设置对象o内存地址偏移量offset指向的byte为x该类型方法表示设置对象o内存地址偏移量offset指向的数据为x void putBoolean(Object o, long offset, boolean x) void putChar(Object o, long offset, char x) void putDouble(Object o, long offset, double x) void putFloat(Object o, long offset, float x) void putInt(Object o, long offset, int x) void putLong(Object o, long offset, long x) void putObject(Object o, long offset, Object x) void putShort(Object o, long offset, short x) byte getByte(Object o, int offset) Deprecated 获得给定对象内存地址偏移量为offset的byte该类型方法表示获得给定对象内存地址偏移量为offset的数据 boolean getBoolean(Object o, int offset) char getChar(Object o, int offset) double getDouble(Object o, int offset) float getFloat(Object o, int offset) int getInt(Object o, int offset) long getLong(Object o, int offset) Object getObject(Object o, int offset) short getShort(Object o, int offset) void putByte(Object o, int offset, byte x) Deprecated 设置对象o内存地址偏移量offset指向的byte为x void putBoolean(Object o, int offset, boolean x) void putChar(Object o, int offset, char x) void putDouble(Object o, int offset, double x) void putFloat(Object o, int offset, float x) void putInt(Object o, int offset, int x) void putLong(Object o, int offset, long x) void putObject(Object o, int offset, Object x) void putShort(Object o, int offset, short x) byte getByteVolatile(Object o, long offset) 获得给定对象内存地址偏移量为offset的byte 并支持volatile语义 boolean getBooleanVolatile(Object o, int offset) char getCharVolatile(Object o, int offset) double getDoubleVolatile(Object o, int offset) float getFloatVolatile(Object o, int offset) int getIntVolatile(Object o, int offset) long getLongVolatile(Object o, int offset) Object getObjectVolatile(Object o, int offset) short getShortVolatile(Object o, int offset) void putByteVolatile(Object o, long offset, byte x) 设置对象o内存地址偏移量offset指向的byte为x 并支持volatile语义 void putBooleanVolatile(Object o, long offset, boolean x) void putCharVolatile(Object o, long offset, char x) void putDoubleVolatile(Object o, long offset, double x) void putFloatVolatile(Object o, long offset, float x) void putIntVolatile(Object o, long offset, int x) void putLongVolatile(Object o, long offset, long x) void putObjectVolatile(Object o, long offset, Object x) void putShortVolatile(Object o, long offset, short x) int getAndAddInt(Object o, long offset, int inc) 根据volatile语义 获得对象内存地址偏移量offset的int值 并增加inc同样有对应的long操作方法 long getAndAddLong(Object o, long offset, long inc) int getAndSetInt(Object o, long offset, int value) 根据volatile语义 获得对象内存地址偏移量offset的int值 并修改为valuelong、Object也有对应的操作方法 long getAndSetLong(Object o, long offset, long value) Object getAndSetObject(Object o, long offset, Object value) long objectFieldOffset(Field f) 获得字段的内存偏移量 long staticFieldOffset(Field f) 获得静态字段的内存偏移量 Object staticFieldBase(Class c) DeprecatedThis method works only for JVMs which store all statics for a given class in one place. Object staticFieldBase(Field f) 获取类的静态字段内存地址偏移量 静态字段的起始地址,类型不是long,而是Object类型 void throwException(Throwable ee) 包装受检异常为运行时异常。 Arrays 数组操纵方法 int arrayBaseOffset(Class arrayClass) 返回给定arrayClass(数组类型Class)第一个元素相对于数组起始地址的偏移量 int arrayIndexScale(Class arrayClass) 返回给定arrayClass(数组类型Class)元素大小(占用多少字节)将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。 Synchronization 多线程同步 锁机制、CAS boolean compareAndSwapInt(Object o, long offset, int expected, int x) 若当前持有值为expected 原子地更新对象o偏移量offset为x boolean compareAndSwapLong(Object o, long offset, long expected, long x) 若当前持有值为expected 原子地更新对象o偏移量offset为x boolean compareAndSwapObject(Object o, long offset, Object expected, Object x) 若当前持有值为expected 原子地更新对象o偏移量offset为x void monitorEnter(Object o) Lock the object void monitorExit(Object o) Unlock the object boolean tryMonitorEnter(Object o) Tries to lock the object. Returns true or false to indicate whether the lock succeeded void park(boolean isAbsolute, long time) 阻塞当前线程阻塞一个线程直到unpark出现、线程被中断或者timeout时间到期。 如果一个unpark调用已经出现了，这里只计数。timeout为0表示永不过期。 当isAbsolute为true时，timeout是相对于新纪元之后的毫秒。 否则这个值就是超时前的纳秒数。这个方法执行时也可能不合理地返回(没有具体原因) void unpark(Thread thread) 释放被park创建的在一个线程上的阻塞。 这个方法也可以被使用来终止一个先前调用park导致的阻塞 Memory 直接内存访问方法（绕过JVM堆直接操纵本地内存） long allocateMemory(long bytes) 分配指定字节的内存块 返回分配的内存地址 long reallocateMemory(long address, long bytes) 重新分配给定地址的内存 void copyMemory(long srcAddress, long destAddress, long bytes) 内存拷贝 从src拷贝到dest 长度为bytes字节 void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes) 内存拷贝 从srcBase偏移量srcOffset拷贝至destBase偏移量destOffset 长度为bytes字节 void freeMemory(long address) 释放给定地址(从allocateMemory、reallocateMemory)获得)的内存 long getAddress(long address) 获取给定内存地址address的指针 void putAddress(long address, long x) 将给定的指针x保存到内存地址address void setMemory(long address, long bytes, byte value) Sets all bytes in a given block of memory to a fixed value (usually zero) void setMemory(Object o, long offset, long bytes, byte value) Sets all bytes in a given block of memory to a fixed value (usually zero) Memory Barrier/Memory Fence 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令， 用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。 有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障。 LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前， 保证Load1要读取的数据被读取完毕。 StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前， 保证Store1的写入操作对其它处理器可见。 LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前， 保证Load1要读取的数据被读取完毕。 StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前， 保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障， 兼具其它三种内存屏障的功能。 void loadFence() LoadLoad屏障 void storeFence() StoreStore屏障 void fullFence() StoreLoad屏障 "}}