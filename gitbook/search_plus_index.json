{"./":{"url":"./","title":"关于本书","keywords":"","body":"jdk8使用示例及源码阅读 jdk版本为1.8.0_131 示例代码 gitbook源码 "},"content/java/":{"url":"content/java/","title":"java","keywords":"","body":"java包 Java SE的标准库，是java标准的一部分，是对外承诺的java开发接口，通常要保持向后兼容，一般不会轻易修改。包括其他厂家(IBMJDK/HPJDK/OpenJDK)在内，所有jdk的实现，在java.*上都是一样的。 "},"content/java/lang/":{"url":"content/java/lang/","title":"lang","keywords":"","body":"java.lang包 该包提供了Java编程的基础类，例如 Object、Math、String、StringBuffer、System、Thread等 "},"content/java/lang/Thread.html":{"url":"content/java/lang/Thread.html","title":"Thread","keywords":"","body":"线程状态转换 "},"content/java/util/":{"url":"content/java/util/","title":"util","keywords":"","body":"java.util包 该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 "},"content/java/util/concurrent/":{"url":"content/java/util/concurrent/","title":"concurrent","keywords":"","body":"java.util.concurrent包 Java5添加了一个新的包到Java平台，java.util.concurrent包。这个包包含有一系列能够让Java的并发编程变得更加简单轻松的类。 "},"content/java/util/concurrent/BlockingQueue/":{"url":"content/java/util/concurrent/BlockingQueue/","title":"BlockingQueue","keywords":"","body":"BlockingQueue BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。 阻塞队列有四种行为无法操作：入队时队列满了或者出队时队列为空 行为 描述 enqueue dequeue 抛异常 无法操作时抛出异常 add(o) remove() 返回特定值 无法操作时返回一个特定值，通常为true/false offer(o) poll() 阻塞 无法操作时会一直阻塞，直到可以正常操作 put(o) take() 超时 无法操作时会阻塞不超过给定超时时间，返回一个特定值 offer(o, timeout, timeunit) poll(timeout, timeunit) BlockingQueue由来及实现 看不清楚新标签中打开大图查看 "},"content/java/util/concurrent/BlockingQueue/ArrayBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/ArrayBlockingQueue.html","title":"ArrayBlockingQueue","keywords":"","body":"ArrayBlockingQueue ArrayBlockingQueue是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。 有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。 你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了 (因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 源码分析 初始化必须指定容量 可选是否为公平锁或者通过一个现有集合(Collection)初始化 ArrayBlockingQueue(int capacity) ArrayBlockingQueue(int capacity, boolean fair) ArrayBlockingQueue(int capacity, boolean fair, Collection c) 属性 // 存储队列元素的数组，是个循环数组 final Object[] items; // 拿数据的索引，用于take，poll，peek，remove方法 int takeIndex; // 放数据的索引，用于put，offer，add方法 int putIndex; // 元素个数 int count; // 可重入锁 final ReentrantLock lock; // notEmpty条件对象，由lock创建 private final Condition notEmpty; // notFull条件对象，由lock创建 private final Condition notFull; 方法 添加元素 boolean offer(E e) public boolean offer(E e) { checkNotNull(e); // null元素抛出NullPointerException final ReentrantLock lock = this.lock; lock.lock(); // 加锁 try { if (count == items.length) return false; // 队列满了返回false else { enqueue(e); // 入队 return true; } } finally { lock.unlock(); // 释放锁 } } private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) // 如果put索引满了 移动到0 putIndex = 0; count++; // 队列元素个数增加 // 使用条件对象notEmpty通知，比如使用take方法的时候队列里没有数据，被阻塞。 // 这个时候队列insert了一条数据，需要调用signal进行通知 notEmpty.signal(); } boolean offer(E e, long timeout, TimeUnit unit) public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); // 将TimeUnit转为纳秒 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) { // 若果队列满了 if (nanos boolean add(E e) public boolean add(E e) { if (offer(e)) // 队列未满 直接添加元素 见上offer方法 return true; else // 否则抛出队列满的异常 throw new IllegalStateException(\"Queue full\"); } void put(E e) public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) notFull.await(); // 如果队列满了阻塞挂起 释放锁 enqueue(e); } finally { lock.unlock(); } } 删除元素 E poll() public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { // 队列空返回null 否者进行出队操作 return (count == 0) ? null : dequeue(); } finally { lock.unlock(); } } private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; // 删除take索引位置的元素 E x = (E) items[takeIndex]; items[takeIndex] = null; // take索引后移 并判断是否需要移动到起始位置 if (++takeIndex == items.length) takeIndex = 0; count--; // 重置迭代器如果take索引回到起始位置 // 如果队列为空 将迭代器置为null if (itrs != null) itrs.elementDequeued(); // 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。 // 这个时候消费了一条数据，队列没满了，就需要调用signal进行通知 notFull.signal(); return x; } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; // 如果当前线程被中断 抛出InterruptedException lock.lockInterruptibly(); try { while (count == 0) { if (nanos E remove() public E remove() { E x = poll(); // 见poll方法 if (x != null) return x; else throw new NoSuchElementException(); } boolean remove(Object o) // 删除一个指定元素 public boolean remove(Object o) { if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { if (count > 0) { // put索引 final int putIndex = this.putIndex; // take索引 int i = takeIndex; // 从take索引遍历到put索引 如果找到删除指定索引位置元素 // 否则 返回false do { if (o.equals(items[i])) { removeAt(i); return true; } if (++i == items.length) i = 0; } while (i != putIndex); } return false; } finally { lock.unlock(); } } void removeAt(final int removeIndex) { // assert lock.getHoldCount() == 1; // assert items[removeIndex] != null; // assert removeIndex >= 0 && removeIndex E take() public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); // 如果队列为空 阻塞到队列非空 return dequeue(); // 出队操作 见E poll() } finally { lock.unlock(); } } 总结 ArrayBlockingQueue底层是一个循环的数组，使用一个重入锁和这个锁生成的两个条件对象进行并发控制。 "},"content/javax/":{"url":"content/javax/","title":"javax","keywords":"","body":"javax包 也是java标准的一部分，但是没有包含在标准库中，一般属于标准库的扩展。通常属于某个特定领域，不是一般性的api。所以以扩展的方式提供api，以避免jdk的标准库过大。当然某些早期的javax，后来被并入到标准库中，所有也应该属于新版本JDK的标准库。比如jmx，java 5以前是以扩展方式提供，但是jdk5以后就做为标准库的一部分了，所有javax.management也是jdk5的标准库的一部分。 "}}