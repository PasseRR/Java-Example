{"./":{"url":"./","title":"关于本书","keywords":"","body":"JDK8源码阅读 jdk版本为1.8.0_131 示例代码 gitbook源码 "},"content/java/":{"url":"content/java/","title":"java","keywords":"","body":"java包 Java SE的标准库，是java标准的一部分，是对外承诺的java开发接口，通常要保持向后兼容，一般不会轻易修改。包括其他厂家(IBMJDK/HPJDK/OpenJDK)在内，所有jdk的实现，在java.*上都是一样的。 "},"content/java/lang/":{"url":"content/java/lang/","title":"lang","keywords":"","body":"java.lang包 该包提供了Java编程的基础类，例如 Object、Math、String、StringBuffer、System、Thread等 "},"content/java/lang/Thread.html":{"url":"content/java/lang/Thread.html","title":"Thread","keywords":"","body":"线程状态转换 "},"content/java/util/":{"url":"content/java/util/","title":"util","keywords":"","body":"java.util包 该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 "},"content/java/util/concurrent/":{"url":"content/java/util/concurrent/","title":"concurrent","keywords":"","body":"java.util.concurrent包 Java5添加了一个新的包到Java平台，java.util.concurrent包。这个包包含有一系列能够让Java的并发编程变得更加简单轻松的类。 "},"content/java/util/concurrent/atomic/":{"url":"content/java/util/concurrent/atomic/","title":"atomic","keywords":"","body":"java.util.concurrent.atomic包 atomic包是专门为线程安全设计的Java包，包含多个原子操作类。 在atomic中频繁的用到了Unsafe，如果不明白可以先看看Unsafe的API。 "},"content/java/util/concurrent/BlockingQueue/":{"url":"content/java/util/concurrent/BlockingQueue/","title":"BlockingQueue","keywords":"","body":"BlockingQueue BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。 阻塞队列有四种行为无法操作：入队时队列满了或者出队时队列为空 行为 描述 enqueue dequeue 抛异常 无法操作时抛出异常 add(o) remove() 返回特定值 无法操作时返回一个特定值，通常为true/false offer(o) poll() 阻塞 无法操作时会一直阻塞，直到可以正常操作 put(o) take() 超时 无法操作时会阻塞不超过给定超时时间，返回一个特定值 offer(o, timeout, timeunit) poll(timeout, timeunit) BlockingQueue由来及实现 看不清楚新标签中打开大图查看 "},"content/java/util/concurrent/BlockingQueue/ArrayBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/ArrayBlockingQueue.html","title":"ArrayBlockingQueue","keywords":"","body":"ArrayBlockingQueue ArrayBlockingQueue是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。 有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。 你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了 (因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 源码分析 初始化必须指定容量 可选是否为公平锁或者通过一个现有集合(Collection)初始化 ArrayBlockingQueue(int capacity) ArrayBlockingQueue(int capacity, boolean fair) ArrayBlockingQueue(int capacity, boolean fair, Collection c) 属性 // 存储队列元素的数组，是个循环数组 final Object[] items; // 拿数据的索引，用于take，poll，peek，remove方法 int takeIndex; // 放数据的索引，用于put，offer，add方法 int putIndex; // 元素个数 int count; // 可重入锁 final ReentrantLock lock; // notEmpty条件对象，由lock创建 private final Condition notEmpty; // notFull条件对象，由lock创建 private final Condition notFull; 方法 添加元素 boolean offer(E e) public boolean offer(E e) { checkNotNull(e); // null元素抛出NullPointerException final ReentrantLock lock = this.lock; lock.lock(); // 加锁 try { if (count == items.length) return false; // 队列满了返回false else { enqueue(e); // 入队 return true; } } finally { lock.unlock(); // 释放锁 } } private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) // 如果put索引满了 移动到0 putIndex = 0; count++; // 队列元素个数增加 // 使用条件对象notEmpty通知，比如使用take方法的时候队列里没有数据，被阻塞。 // 这个时候队列insert了一条数据，需要调用signal进行通知 notEmpty.signal(); } boolean offer(E e, long timeout, TimeUnit unit) public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); // 将TimeUnit转为纳秒 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) { // 若果队列满了 if (nanos boolean add(E e) public boolean add(E e) { if (offer(e)) // 队列未满 直接添加元素 见上offer方法 return true; else // 否则抛出队列满的异常 throw new IllegalStateException(\"Queue full\"); } void put(E e) public void put(E e) throws InterruptedException { checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) notFull.await(); // 如果队列满了阻塞挂起 释放锁 enqueue(e); } finally { lock.unlock(); } } 移除元素 E poll() public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { // 队列空返回null 否者进行出队操作 return (count == 0) ? null : dequeue(); } finally { lock.unlock(); } } private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; // 删除take索引位置的元素 E x = (E) items[takeIndex]; items[takeIndex] = null; // take索引后移 并判断是否需要移动到起始位置 if (++takeIndex == items.length) takeIndex = 0; count--; // 重置迭代器如果take索引回到起始位置 // 如果队列为空 将迭代器置为null if (itrs != null) itrs.elementDequeued(); // 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。 // 这个时候消费了一条数据，队列没满了，就需要调用signal进行通知 notFull.signal(); return x; } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; // 如果当前线程被中断 抛出InterruptedException lock.lockInterruptibly(); try { while (count == 0) { if (nanos E remove() public E remove() { E x = poll(); // 见poll方法 if (x != null) return x; else throw new NoSuchElementException(); } boolean remove(Object o) // 删除一个指定元素 public boolean remove(Object o) { if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try { if (count > 0) { // put索引 final int putIndex = this.putIndex; // take索引 int i = takeIndex; // 从take索引遍历到put索引 如果找到删除指定索引位置元素 // 否则 返回false do { if (o.equals(items[i])) { removeAt(i); return true; } if (++i == items.length) i = 0; } while (i != putIndex); } return false; } finally { lock.unlock(); } } void removeAt(final int removeIndex) { // assert lock.getHoldCount() == 1; // assert items[removeIndex] != null; // assert removeIndex >= 0 && removeIndex E take() public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); // 如果队列为空 阻塞到队列非空 return dequeue(); // 出队操作 见E poll() } finally { lock.unlock(); } } 总结 ArrayBlockingQueue底层是一个循环的数组，使用一个重入锁和这个锁生成的两个条件对象进行并发控制。 其他方法都会加锁比如contains、toArray、drainTo、clear、toString。 "},"content/java/util/concurrent/BlockingQueue/LinkedBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/LinkedBlockingQueue.html","title":"LinkedBlockingQueue","keywords":"","body":"LinkedBlockingQueue LinkedBlockingQueue是一个基于单链表的无界阻塞队列，它跟ArrayBlockingQueue一样都是通过使用ReentrantLock来保证线程安全的。 但是LinkedBlockingQueue有两把锁，即put重入锁和take重入锁。ArrayBlockingQueue中put和take只能有一个被执行，不允许并行执行。 LinkedBlockingQueue允许take和put并行执行，当然只能有1个线程各自运行。 LinkedBlockingQueue不允许null值，也不强制我们指定队列得初始容量，默认的容量为Integer.MAX_VALUE。 源码分析 初始化若指定容量以指定为准，否则容量为Integer.MAX_VALUE，也可以使用一个现有集合来初始化 LinkedBlockingQueue() LinkedBlockingQueue(int capacity) LinkedBlockingQueue(Collection c) 属性 // 链表容量 private final int capacity; // 当前队列元素数量 // 由于有take、put两把锁 需要使用AtomicInteger来保证队列元素数量线程安全 private final AtomicInteger count = new AtomicInteger(); // 链表头 transient Node head; // 链表尾 private transient Node last; // take重入锁 private final ReentrantLock takeLock = new ReentrantLock(); // 非空条件 由take重入锁创建 private final Condition notEmpty = takeLock.newCondition(); // put重入锁 private final ReentrantLock putLock = new ReentrantLock(); // 非满条件 由put重入锁创建 private final Condition notFull = putLock.newCondition(); // 链表节点 static class Node { E item; /** * One of: * - the real successor Node * - this Node, meaning the successor is head.next * - null, meaning there is no successor (this is the last node) */ Node next; Node(E x) { item = x; } } 方法 添加元素 boolean offer(E e) public boolean offer(E e) { // LinkedBlockingQueue不允许null if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; // 如果队列满了返回false if (count.get() == capacity) return false; int c = -1; Node node = new Node(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try { // 双重校验队列是否满 if (count.get() = 0; } private void enqueue(Node node) { // 入队的时候只在last尾节点添加元素 // Java是自右向左逐一赋值的，比如：A=B=C=0，首先给C赋值0，即C=0，然后B=C;最后A=B // 故此处为先将last.next地址指向node 即将head链表增加一个节点 // 再将last地址指向last.next 即last指向最后一个节点 last = last.next = node; } private void signalNotEmpty() { final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { notEmpty.signal(); } finally { takeLock.unlock(); } } boolean offer(E e, long timeout, TimeUnit unit) public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { // 跟offer(E e)方法的主要区别 // 等待给定timeout // 超时则返回false 否则进行入队操作 while (count.get() == capacity) { if (nanos (e)); c = count.getAndIncrement(); if (c + 1 boolean add(E e) public boolean add(E e) { if (offer(e)) // 见上offer(E e)方法 return true; else throw new IllegalStateException(\"Queue full\"); } void put(E e) public void put(E e) throws InterruptedException { if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node node = new Node(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try { /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ // 如果队列是满的 阻塞到队列非满 while (count.get() == capacity) { notFull.await(); } enqueue(node); c = count.getAndIncrement(); if (c + 1 移除元素 E poll() public E poll() { final AtomicInteger count = this.count; if (count.get() == 0) // 如果队列为空 直接返回null return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try { if (count.get() > 0) { x = dequeue(); // 出队核心方法 c = count.getAndDecrement(); if (c > 1) notEmpty.signal(); } } finally { takeLock.unlock(); } // 和入队类似 如果在删除元素前队列是满的 // 此时c等于capacity 但实际元素个数只有capacity-1个 // 故唤醒put线程 可以进行入队操作 if (c == capacity) signalNotFull(); return x; } private E dequeue() { Node h = head; // 将h指向当前头结点 Node first = h.next; // 将first指向第二个节点 h.next = h; // help GC // h指向h后一个节点 head = first; // 将头结点指向第二个节点 E x = first.item; // 获得队首的元素 first.item = null; // 删除队首元素 return x; } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { // 等待timeout 超时返回null 否则删除元素 while (count.get() == 0) { if (nanos 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } E remove() public E remove() { E x = poll(); // 见上poll()方法 if (x != null) return x; else // 队列为空抛出异常 throw new NoSuchElementException(); } boolean remove(Object o) // 删除指定元素 public boolean remove(Object o) { if (o == null) return false; // 跟其他删除不同 这里加的是全锁即take、put锁 // 因为指定元素可能不在队首 fullyLock(); try { // 从head开始遍历 直到next不为null for (Node trail = head, p = trail.next; p != null; trail = p, p = p.next) { if (o.equals(p.item)) { // p为要删除节点 // trail为p的前一个节点 unlink(p, trail); return true; } } return false; } finally { fullyUnlock(); } } void unlink(Node p, Node trail) { // assert isFullyLocked(); // p.next is not changed, to allow iterators that are // traversing p to maintain their weak-consistency guarantee. p.item = null; // 移除节点元素 trail.next = p.next; // 连接移除节点前后节点 if (last == p) // 如果删除节点为队尾 last = trail; // 将last节点指向trail if (count.getAndDecrement() == capacity) // 删除元素前队列是满的 唤醒put线程 notFull.signal(); } E take() public E take() throws InterruptedException { E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try { // 如果队列为空 阻塞到队列为非空 while (count.get() == 0) { notEmpty.await(); } x = dequeue(); c = count.getAndDecrement(); if (c > 1) notEmpty.signal(); } finally { takeLock.unlock(); } if (c == capacity) signalNotFull(); return x; } 总结 LinkedBlockingQueue底层是一个单链表，使用put锁、take锁和两锁生成的条件对象进行并发控制。 其他方法都会加全锁(即put、take锁)比如contains、toArray、drainTo、clear、toString。 "},"content/java/util/concurrent/BlockingQueue/PriorityBlockingQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/PriorityBlockingQueue.html","title":"PriorityBlockingQueue","keywords":"","body":"PriorityBlockingQueue "},"content/java/util/concurrent/BlockingQueue/DelayQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/DelayQueue.html","title":"DelayQueue","keywords":"","body":"DelayQueue DelayQueue对元素进行持有直到一个特定的延迟到期，不允许null元素且注入其中的元素必须实现java.util.concurrent.Delayed接口。 PriorityQueue是一个根据队列里元素某些属性排列先后的顺序队列，DelayQueue其实就是在每次往优先级队列中添加元素， 然后以元素的delay过期值作为排序的因素，以此来达到先过期的元素会排在队首，每次从队列里取出来都是最先过期的元素。 源码分析 DelayQueue是容量无界的最大为Integer.MAX_VALUE，默认容量为11，若容量不够以当前容量50%递增， 可以使用一个现有集合对象初始化。 DelayQueue() DelayQueue(Collection c)元素需要实现的接口Delayed public interface Delayed extends Comparable { /** * Returns the remaining delay associated with this object, in the * given time unit. * * @param unit the time unit * @return the remaining delay; zero or negative values indicate * that the delay has already elapsed */ long getDelay(TimeUnit unit); } 属性 // 重入锁 private final transient ReentrantLock lock = new ReentrantLock(); // 锁条件对象 private final Condition available = lock.newCondition(); // 根据delay时间排序的优先队列 private final PriorityQueue q = new PriorityQueue(); /** * Thread designated to wait for the element at the head of * the queue. This variant of the Leader-Follower pattern * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to * minimize unnecessary timed waiting. When a thread becomes * the leader, it waits only for the next delay to elapse, but * other threads await indefinitely. The leader thread must * signal some other thread before returning from take() or * poll(...), unless some other thread becomes leader in the * interim. Whenever the head of the queue is replaced with * an element with an earlier expiration time, the leader * field is invalidated by being reset to null, and some * waiting thread, but not necessarily the current leader, is * signalled. So waiting threads must be prepared to acquire * and lose leadership while waiting. */ // 用于优化阻塞通知的线程元素leader 用leader来减少不必要的等待时间 // private Thread leader = null; leader的作用? leader的主要作用用于减少不必要的阻塞时间，例如有多个消费者线程用take方法去取， 内部先加锁，然后每个线程都去peek第一个节点。如果leader不为空说明已经有线程在取了，设置当前线程阻塞。 如果为空说明没有其他线程去取这个节点，设置leader并等待delay延时到期，直到poll后结束循环。 方法 添加元素 boolean offer(E e) public boolean offer(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { q.offer(e); // 优先队列入队 if (q.peek() == e) { // 查看元素是否是优先队列队首 leader = null; // 设置leader为空 唤醒take线程 available.signal(); } return true; } finally { lock.unlock(); } } boolean offer(E e, long timeout, TimeUnit unit)同offer(E e)方法 因为队列没有容量限制故没有超时的offer方法 boolean add(E e)同offer(E e)方法 因为队列没有容量限制故没有抛出异常的add方法 void put(E e)同offer(E e)方法 因为队列没有容量限制故没有阻塞的put方法 移除元素 E poll() public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { E first = q.peek(); // 查看优先队队首 // 如果优先队列为空或队首delay时间为达到返回null if (first == null || first.getDelay(NANOSECONDS) > 0) return null; else return q.poll(); // 优先队列出队 } finally { lock.unlock(); } } E poll(long timeout, TimeUnit unit) public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { E first = q.peek(); if (first == null) { // 当优先队列为空时 if (nanos 出队方法中为什么要释放first元素? 假如有线程A和B都来获取队首，如果线程A阻塞完毕，获取对象成功，出队完成。 这个对象理应被GC回收，但是他还被线程B持有着，GC链可达，所以不能回收这个first。 E remove() public E remove() { E x = poll(); // 见上poll()方法 if (x != null) return x; else throw new NoSuchElementException(); } boolean remove(Object o) public boolean remove(Object o) { final ReentrantLock lock = this.lock; lock.lock(); try { // 调用优先队列remove(Object o)方法 return q.remove(o); } finally { lock.unlock(); } } E take() public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { E first = q.peek(); if (first == null) // 如果队首为null 阻塞当前线程 available.await(); else { long delay = first.getDelay(NANOSECONDS); if (delay 总结 DelayQueue底层是一个优先队列(java.util.PriorityQueue)，使用一个重入锁和锁生成的条件对象进行并发控制。 toArray、drainTo、clear都加锁但contains、toString未加锁。 "},"content/java/util/concurrent/BlockingQueue/SynchronousQueue.html":{"url":"content/java/util/concurrent/BlockingQueue/SynchronousQueue.html","title":"SynchronousQueue","keywords":"","body":"SynchronousQueue "},"content/javax/":{"url":"content/javax/","title":"javax","keywords":"","body":"javax包 也是java标准的一部分，但是没有包含在标准库中，一般属于标准库的扩展。通常属于某个特定领域，不是一般性的api。所以以扩展的方式提供api，以避免jdk的标准库过大。当然某些早期的javax，后来被并入到标准库中，所有也应该属于新版本JDK的标准库。比如jmx，java 5以前是以扩展方式提供，但是jdk5以后就做为标准库的一部分了，所有javax.management也是jdk5的标准库的一部分。 "},"content/sun/misc/Unsafe.html":{"url":"content/sun/misc/Unsafe.html","title":"Unsafe","keywords":"","body":"Unsafe Unsafe类在jdk源码的多个类中用到，这个类的提供了一些绕开JVM的更底层功能，基于它的实现可以提高效率。 但是，它是一把双刃剑：正如它的名字所预示的那样，它是Unsafe的，它所分配的内存需要手动free（不被GC回收）。 Unsafe类，提供了JNI某些功能的简单替代：确保高效性的同时，使事情变得更简单。 更多信息请前往API查看。 API Unsafe API的大部分方法都是native实现，它由105个方法组成，主要包括以下几类 Info 获得某些低级别的内存信息 int addressSize() 返回内存地址长度4或者8字节 取决于jvm内存多少 如果堆大于32G则为8字节 小一点的堆则为4字节 Objects 提供Object和它的Field操纵方法 Object allocateInstance(Class cls) 绕过构造方法直接初始化实例对象且不会初始化属性 对象类型属性为null 基本类型为默认值 Class 提供Class和它的静态Field操纵方法 Arrays 数组操纵方法 int arrayBaseOffset(Class arrayClass) 返回给定arrayClass(数组类型Class)第一个元素相对于数组起始地址的偏移量 int arrayIndexScale(Class arrayClass) 返回给定arrayClass(数组类型Class)元素大小(占用多少字节)将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。 Synchronization 提供低级别同步原语（如基于CPU的CAS（Compare-And-Swap）原语） boolean compareAndSwapInt(Object o, long offset, int expected, int x) 若当前持有值为expected 原子地更新对象o偏移量offset为x boolean compareAndSwapLong(Object o, long offset, long expected, long x) 若当前持有值为expected 原子地更新对象o偏移量offset为x boolean compareAndSwapObject(Object o, long offset, Object expected, Object x) 若当前持有值为expected 原子地更新对象o偏移量offset为x Memory 直接内存访问方法（绕过JVM堆直接操纵本地内存） long allocateMemory(long bytes) 分配指定字节的内存块 返回分配的内存地址 void copyMemory(long srcAddress, long destAddress, long bytes) 内存拷贝 从src拷贝到dest 长度为bytes字节 void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes) 内存拷贝 从srcBase偏移量srcOffset拷贝至destBase偏移量destOffset 长度为bytes字节 "}}